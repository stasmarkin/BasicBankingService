============
Код и сервер
============

Код: https://github.com/stasmarkin/BasicBankingService
Сервер: simplebank.stasmarkin.ru:8080

Сейчас на сервере 100_000 аккаунт с балансом 100_000 с идущими подряд айдишниками от 1

В ридми проекта есть подробные описания запросов,
а ниже приведу просто курлы для пробы:
```
# BALANCE \
curl -X POST -H "Content-Type: application/json" \
    -d '{"accId": 100}' \
    http://simplebank.stasmarkin.ru:8080/api/v1/balance

# TRANSFER \
curl -X POST -H "Content-Type: application/json" \
    -d '{"senderId": 100, "recipientId": 101, "amount": 10}' \
    http://simplebank.stasmarkin.ru:8080/api/v1/transfer

# CREATE \
curl -X POST -H "Content-Type: application/json" \
    -d '{"accId": 7777777, "amount": 50000000}' \
    http://simplebank.stasmarkin.ru:8080/api/v1/create
```

===========================
Функциональное тестирование
===========================

# Создал базу 10_000 акков с балансами 1_000_000
# Глазами проверил ответ на баланс существующего в базе аккаунта
# Глазами проверил ответ на баланс несуществующего в базе аккаунта
# Посмотрел в базе баланс двух разных акков, запомнил
# Сделал запрос перевода с одного на другой, проверил глазами ответ, проверил в базе
# Сделал запрос перевода с одного на другой огромной суммы, получил 400, проверил в базе
# Сделал запрос перевода с одного на другой отрицательной суммы, получил 400, проверил в базе
# Сделал запрос перевода с несуществующего на существуюй, получил 400, проверил в базе
# Сделал запрос перевода с существующего на несуществуюй, получил 400, проверил в базе
# Запустил стресс тест на переводы с рандомнго акка на рандомный, остановил после 10к+ запросов, проверил что в базе сумма балансов всех аккаунтов равна 10_000 * 1_000_000
# Запустил стресс тест на переводы с рандомнго акка на несуществуюе, остановил после 10к+ запросов, проверил что в базе сумма балансов всех аккаунтов равна 10_000 * 1_000_000
# Реинициализировал базу в 10_000 акков с балансами 1_000_000
# Запустил стресс тест в 10к запросов на переводы $10 с рандомного (кроме id1) акка на id1,
  проверил что в базе баланс у первого равен 1_000_000 + 10 * 10_000
# Создал аккаунт с несуществуюм id, проверил в базе
# Создал аккаунт с этим же id, но другой суммой, получил фейл, проверил в базе, что сумма осталась старая
# Запустил нагрузочное тестирование и проверил что реальное распределение кодов ответа соответвует ожиданиям


========================
Нагрузочное тестирование
========================

Я сделал утилитку, которая в асинхронной манере запускает http-запросы таким образом,
чтобы всегда поддерживать заданное кол-во одновременных запросов к сервису.
Натравил ее на "продакшен".
В этой утилитке есть понятие "сценарий" -- это то, какой тип запроса будет создан.
Есть несколько сценариев:
balance -- запрос на баланс случайного существующего акка
balanceMissed -- запрос на баланс случайного несуществующего акка
transferRnd2rnd -- запрос на трансфер со случайного существующего на случайный существующий акк
transferRnd2one -- запрос на трансфер со случайного существующего на акк с id1
transferRnd2none -- запрос на трансфер со случайного существующего на случайный несуществующий акк
create -- запрос на создание акка с несуществующим id
createDuplicate -- запрос на создание акка с существующим id
Для каждого сценария можно определить вес и соответственно погонять стресс-тест под нужным профилем нагрузки.


======================
Пропускная способность
======================

Только запросы на баланс работают с ~2700 RPS
Только запросы на трансфер (со случайного аккаунта на случайный) ~950 RPS
Только запросы на трансфер (со случайного аккаунта на один фиксированный) ~170 RPS
Только запросы на создание аккаунта ~2200 RPS
Смешанные запросы (85% баланс, 15% случайный трансфер, 5% создание акка) ~2200 RPS


================
Как улучшить RPS
================

Есть 2 основных метода:
1. Сделать хранилище балансов в памяти. Оно должно отвечать следующим свойствам:
-- Выгружает аккаунт из базы
-- Все операции над балансом происходят на атомиках, а фоновый процесс синхронизирует изменения с БД
-- Должна быть стратегия выгрузки аккаунта из памяти, чтобы не держать в итоге всю базу в памяти

Таким образом, почти все http-запросы будет работать только с атомиками в памяти, им даже не потребуется брать блокировки на аккаунты.

2. Сейчас все запросы упираются в работу с базой.
В лучшем случае запросов на баланс, у нас не справляются SQLConnection-ы
В худшем случае запросов на трансфер на один и тот же аккаунт, у нас строгое требование по лианеризации, и по сути мы упираемся в раунд-трипы до базы.
Для обоих случаем можно уменьшить кол-во запросов батчами. Для примера, возьмем трансферы, пусть в нас в очереди сейчас такое:
acc4 -> acc1 : 400
acc3 -> acc1 : 300
acc1 -> acc2 : 200

мы выгружаем всю эту очередь, считаем все уникальные акканты : acc1, acc2, acc3, acc4.
Берем локи на эти аккаунты. Если лок не полчается взять, то возвращаем один этот конкретный запрос обратно в очередь.
Далее для этих аккаунтов выгружаем балансы единым запросом и в памяти применяем все запросы.
Далее обновляем базу, желательно единым или несколькими запросами (но точно не по запросу на акк).
Отпускаем локи, высталяем нужные ответы запросам.

Я такие батчи много писал, в целом можно получить прирост производительности порядка 100 раз (+- в зависимости от специфики запросов).
Но для конкретного сервера это в любом случае недостижимо, т.к. после базы все начнет упираться в пропускную способоность http-сервера.
На этом железе он держит где-то 10k-12k RPS сам по себе, т.е. если добавить нагрузку от батчей, по ощущениям можно будет добиться 8-9к RPS.


============================
Что не хватает до продакшена
============================
Ниже я перечислил минимум именно по коду (без окружения)

# Контроль над тредпулами
 Сейчас в приложении нет никакого управления пулами.
 Обычно для продакшена я выношу все настройки пулов в отдельный конфиг
 + нужно аккуратно проверить все навешивание коллбэков во фьючах.
 Сейчас, например, sql-ные треды пишут ответы на http-запросы, а эту работу все-таки лучше отдавать netty-вским тредам

# Рефакторинг
 Сейчас есть немного повторяющегося кода для каждого запроса + всталенны какие-то небольшие костылики (напрмер, генерация overloaded-запросов: { CreateResponse.overloaded() })
 А добавление нового запроса требует изменения кода сразу во многих местах
 Я бы сделал какие обощенные классы BalanceCommand, TransferCommand и тд, в которых содержалась бы вся инфа, по какому урлу сидят, что принимают, что отдают, и метод на обработку единичного запроса.
 Тогда можно было бы через DI собирать все это CommandProcessor-ы, регистритровать их в http-сервере и едином CommandProcessor-ре (который сейчас называется AccountProcessor).
 Ну да, и DI надо сделать :)

# Логи
 Нужны логи на любое общение вне JVM: база и http-запросы
 Нужна трассировка в методах такая, что при желании можно было бы восстаносить ход операций.

# Метрики
 Кол-во запросов, квантили времени запроса, статистика кодов ответов
 Телеметрия с всех пулов
 Размеры очередей
 Эксепшены


